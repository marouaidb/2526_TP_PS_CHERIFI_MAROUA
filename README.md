# TP PROGRAMMATION SYSTEME
#### CHERIFI Sacha
#### IDBAHA Maroua

This project implements a minimal Unix shell named **enseash**, developed incrementally through several questions.
Each step introduces core system programming concepts such as low-level I/O , process creation, and process termination handling.

## Question 1 — Welcome Message and Prompt Display

#### Objective:

At startup, the shell must:
- display a welcome message,
- indicate how to exit the shell,
- then show a prompt inviting the user to enter commands.

#### Implementation Principle:

This question focuses on **basic output handling** using low-level system calls.

- Output is written directly to **STDOUT** using `write()`.
- No higher-level I/O functions such as printf are used.
- No user input is processed at this stage.

#### Output

![Shell output](img/q10.png)


## Question 2 — Reading and Executing Simple Commands

#### Q2a — Reading User Input

The shell waits for user input using the system call :

```c
read(STDIN_FILENO, buffer, size);
```

**Key points:**
- Input is read from standard input (`STDIN`) using the `read()` system call.
- The number of bytes read is stored and checked to detect special cases (e.g. EOF).
- The newline character (`\n`) generated by pressing Enter is removed.
- The input buffer is converted into a valid C string by appending the null terminator (`\0`).
- Only simple commands without arguments are handled at this stage.

####  Q2b — Executing a Command

To execute a command, the shell relies on **process creation and execution** mechanisms provided by Unix systems.

The execution workflow is the following:

- `fork()` is used to create a **child process**
- The child process replaces its code using `execlp()` to execute the requested command
- The parent process waits for the child to terminate using `wait()`

This separation ensures that:
- the shell itself continues running,
- the executed command runs independently in the child process.

#### Q2c — Command Loop

The shell execution logic is implemented inside an infinite loop (`while(1)`) :

- The prompt is displayed at the beginning of each iteration
- User input is read and processed at each loop iteration
- Each command is executed independently in a child process
- After command execution, the shell returns to the prompt and waits for new input

This allows the shell to continuously process commands until it is explicitly terminated.

#### Summary

```mermaid
flowchart TD
    A["Display prompt to user"] --> B["Read user input from keyboard"]
    B --> C["Clean input remove newline and add null terminator"]
    C --> D["Create a new child process to run the command"]
    D -->|Child process| E["Child executes the command"]
    E -->|If command fails| F["Child prints error message and terminates"]
    D -->|Parent process| G["Parent waits for the child to finish"]
    G --> H["Parent resumes execution after child finishes"]
    H --> A
```

#### Output

![Shell output](img/q21.png)
![Shell output](img/q22.png)

## Question 3 — Handling exit and Ctrl+D

#### Objective:
The shell must terminate cleanly in two cases:
- When the user enters the `exit` command.
- When `read()` returns `0`, indicating an end-of-file (Ctrl+D).

In both cases, the shell exits after displaying a termination message.

These conditions allow the shell to be closed in a controlled and predictable manner.

#### Summary

```mermaid
flowchart TD
    A["Display prompt"] --> B["read STDIN and replace newline with null"]
    B -->|Ctrl+D| C["Print exit message and exit shell"]
    B -->|Input is 'exit'| C
    B -->|Empty command Enter| D["Continue loop without executing"]
    B -->|Any other command| E["Continue to execute command"]
```
#### Output

![Shell output](img/q31.png)
![Shell output](img/q32.png)

## Question 4 — Displaying the Command Termination Status
#### Objective:

After executing a command, the shell updates its prompt to indicate the termination status of the previously executed command.

#### Termination Analysis :

When a command finishes, the parent process retrieves its termination status using the system call:
```c
wait(&status);
```

Two termination cases exist in Unix systems :

1-  *Normal termination* (the command exits using return or exit()) :

Every command returns an exit code when it finishes:
- Exit code 0 means that the command executed successfully.
- Exit code different from 0 means that an error occurred during execution.

For example:

- The command `true` always succeeds and therefore returns exit code 0.
- The command `false` always fails and therefore returns exit code 1.
- If a command does not exist or cannot be executed, it also returns a non-zero exit code.

In the shell, this exit code is displayed in the prompt:
```text
enseash [exit:N] %
```
Where `N` corresponds to the exit code returned by the previously executed command.

![Shell output](img/q42.png)

This behavior allows the shell to indicate whether the last command succeeded or failed.

2- *Termination by signal* :  the shell detects and reports a command that terminates abnormally, i.e. interrupted by a signal (e.g. segmentation fault, kill).

To test this behavior, a dedicated program `test_signal_-q4` is executed from the shell.

This program:

- retrieves its own process identifier using `getpid()`,
- enters an infinite loop,
- periodically prints its PID to indicate that it is running,
- can only be stopped by receiving an external signal.

As long as no signal is sent, the program runs normally.

Two terminals are used:

![Shell output](img/q41.png)

1. **First terminal**

The program `test_signal_q4` is launched from `enseash`.  
The shell displays that the process is running and prints its PID repeatedly.

2. **Second terminal**

The process is terminated manually using the command:

```bash
kill -9 <pid>
```
where `<pid>` corresponds to the PID printed by the running program.

After receiving the signal:

- the running program stops immediately,
- control returns to the shell,
- the prompt is updated to indicate signal-based termination

The shell displays:

```text
enseash [sign:9] %
```
This confirms that : 
- the process did not terminate normally,
- it was interrupted by signal number 9 (`SIGKILL`).

#### Summary

```mermaid
flowchart TD
    A["display_status(status)"] --> B["status < 0 ?"]

    B -->|Yes| C["Display simple shell prompt<br/>write(SHELL_PROMPT)"]

    B -->|No| D["WIFEXITED(status) ?"]
    D -->|Yes| E["Display exit code<br/>WEXITSTATUS(status)"]

    D -->|No| F["WIFSIGNALED(status) ?"]
    F -->|Yes| G["Display signal number<br/>WTERMSIG(status)"]

    F -->|No| H["No output"]
```

## Question 5 - Measuring Command Execution Time

###  Objective

The goal of this question is to measure the **execution time of each command** and display it directly in the shell prompt.

The prompt format is extended to include the execution duration in milliseconds:

```text
enseash [exit:N|Tms] %
enseash [sign:S|Tms] %
```

Where :

- N is the exit code returned by the command,
- S is the signal number if the command was terminated by a signal,
- T represents the execution time in milliseconds.

###  Implementation Principle

To measure the execution time, the shell uses the system call:

```c
clock_gettime(CLOCK_MONOTONIC, &ts);
```
Two timestamps are recorded:

- one just before launching the command,
- one just after the command terminates.

The difference between these two timestamps gives the execution duration of the command.

The clock `CLOCK_MONOTONIC` is used to ensure that the measured time is not affected by system clock changes.

###  Observed Behavior

After executing a command, the shell displays both:
- the termination status (exit code or signal).
- the execution time.

#### Output
![Shell output](img/q50.png)

## Question 6 - 

#### Summary


```mermaid
---
title: find_arguments – Parsing Command into Arguments
---
flowchart TD
    A["Receive command line string"] --> B["Split command using spaces (strsep)"]

    B --> C["Ignore empty arg"]
    C --> D["Store arg in args[]"]

    D --> E["Limit number of arguments (ARGS_MAXSIZE)"]
    E --> F["Terminate args[] with NULL"]

    F --> G["args[] ready for execvp"]
```

```mermaid
---
title: execute_complex_command 
---
flowchart TD
    A["Shell receives args[]"] --> B["fork()"]

    B -->|Child process| C["execvp(args[0], args)"]
    C -->|Failure| D["perror('enseash')<br/>exit(EXIT_FAILURE)"]

    B -->|Parent process| E["wait(status)"]
    E --> F["Shell ready for next command"]
```


#### Output

![Shell output](img/q60.png)

## Question 7 - 

#### Summary

*(**find_redirection**) is always called in main. It determines whether the command to be executed is a simple command or a complex command that uses redirection. In addition, it provides the position of the redirection symbol within the argument array.*

```mermaid
---
title: find_redirection – Redirection Symbol Detection
---
flowchart TD
    A["Start scanning args[]"] --> B{"args[i] != NULL ?"}

    B -->|No| H["Return REDIR_NONE"]

    B -->|Yes| C{"args[i] == '<' ?"}
    C -->|Yes| D["Set position = i<br/>Return REDIR_IN"]

    C -->|No| E{"args[i] == '>' ?"}
    E -->|Yes| F["Set position = i<br/>Return REDIR_OUT"]

    E -->|No| G["i++"]
    G --> B
```

```mermaid
---
title: apply_redirection – File Descriptor Configuration
---
flowchart TD
    A["apply_redirection(args, position, type)"] --> B["Get file name = args[position + 1]"]

    B --> C{"type == REDIR_IN ?"}

    C -->|Yes| D["Open file (O_RDONLY)"]
    C -->|No| E["Open file (O_WRONLY | O_CREAT | O_TRUNC)"]

    D --> F{"fd == -1 ?"}
    E --> F

    F -->|Yes| G["perror('open')<br/>exit(EXIT_FAILURE)"]
    F -->|No| H["dup2(fd, STDIN or STDOUT)"]

    H --> I["close(fd)"]
    I --> J["args[position] = NULL"]
```

```mermaid
---
title: execute_complex_command_redir – Command Execution with Redirection
---
flowchart TD
    A["execute_complex_command_redir(args, status, position, type)"] --> B["fork()"]

    B -->|Child| C["apply_redirection()"]
    C --> D["execvp(command)"]
    D -->|Fail| E["perror + exit"]

    B -->|Parent| F["wait(status)"]
    F --> J["Shell ready for next command"]
```


#### Output

![Shell output](img/q71.png)

![Shell output](img/q72.png)

## Question 8 - 

#### Summary

*Pour **find_redirection_and_pipe** on ajoute juste un strcmp sur "|" à find_redirection* de question 7.

```mermaid
---
title: execute_complex_command_pipe – Command Execution with pipe
---
flowchart TD
    A["execute_complex_command_pipe(args, status, position)"] --> B["Create pipe()"]

    B -->|Failure| C["perror('pipe')<br/>Return"]
    B -->|Success| D["Split args at '|'"]

    D --> E["fork() → pid1"]

    E -->|Child 1| F["Redirect stdout to pipe write end<br/>dup2(fd_write, STDOUT)"]
    F --> G["Close pipe fds"]
    G --> H["execvp(left command)"]
    H -->|Fail| I["perror + exit"]

    E -->|Parent| J["fork() → pid2"]

    J -->|Child 2| K["Redirect stdin to pipe read end<br/>dup2(fd_read, STDIN)"]
    K --> L["Close pipe fds"]
    L --> M["execvp(right command)"]
    M -->|Fail| N["perror + exit"]

    J -->|Parent| O["Close pipe fds"]
    O --> P["waitpid(pid1)"]
    P --> Q["waitpid(pid2)"]
    Q --> R["Shell ready for next command"]
```

#### Output

![Shell output](img/q80.png)







